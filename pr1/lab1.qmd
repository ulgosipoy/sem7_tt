---
title: "Практическое работа 1"
author: "БИСО-01-20 Калбак"
format: 
  md:
    output-file: README.md
---

# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования R;
2.  Оформить отчет по изученному материалу.

## Исходные данные

1.  ОС Windows 10
2.  Интерпретатор языка R 4.3.0
3.  RStudio Desktop
4.  Библиотека `Swirl`

## План

1.  Установить библиотеку `swirl`
2.  Запустить в консоли `swirl::swirl()`
3.  Пройти 4 урока

## Ход выполнения работы

Для начала, установим библиотеку `swirl`.

```         
install.packages("swirl")
```

После этого запустим библиотеку с помощью команды `swirl::swirl()`.

```         
swirl::swirl()
```

### Урок 1: Основные блоки программирования на языке R

Интерактивный калькулятор - самая простая форма, которая может использоваться в R. Введите `5 + 7` и нажмите Enter.

```{r}
5 + 7
```

Чтобы присвоить результат `5 + 7` новой переменной с именем `x`, вводите `x <- 5 + 7`. Это можно прочитать как `x gets 5 plus 7`. Чтобы просмотреть содержимое переменной `x`, просто введите `x` и нажмите Enter.

```{r}
x <- 5 + 7
x
```

Теперь сохраните результат `x - 3` в новой переменной `y`.

```{r}
y <- x - 3
y
```

Самый простой способ создать вектор - с помощью функции c(), которая расшифровывается как `concatenate` или `combine`. Чтобы создать вектор, содержащий числа 1.1, 9 и 3.14, введите `c(1.1, 9, 3.14)`. Сохраним результат в переменную`z`.

```{r}
z <- c(1.1, 9, 3.14)
z
```

Введите `?c` и нажмите Enter. Откроется файл справки для функции c(). 

```{r}
?c
```

Вы можете объединить векторы, чтобы создать новый вектор. Создадим новый вектор, содержащий `z, 555, z` в указанном порядке.

```{r}
c(z, 555, z)
```

Числовые векторы могут использоваться в арифметических выражениях. Операции будут производиться с каждым элементом вектора.

```{r}
z * 2 + 100
```

Наиболее часто встречающиеся операции `+`, `-`, `/`, `*`, `^` могут прописываться напрямую. Однако чтобы вычислить корень, нужно использовать команду `sqrt()`, а чтобы взять по модулю - `abs()`. Попробуем вычислить корень из z - 1 и занести в переменную `my_sqrt`. Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление по корню применялось к каждому из них.

```{r}
my_sqrt <- sqrt(z - 1)
my_sqrt
```

Создадим новую переменную `my_div` и занесём туда результат деления значений `z` на `my_sqrt`. Затем узнаем что получилось в итоге и убедимся, что операция выполняется по элементам (т.е. первому элементу первого вектора соответствует первый элемент второго вектора).

```{r}
my_div <- z / my_sqrt
my_div
```

Чтобы увидеть другой пример того, как работает эта векторная "переработка", попробуем добавить `c(1, 2, 3, 4)` и `c(0, 10)`. Видим, что самый короткий вектор повторяется снова, пока более длинный не закончится.

```{r}
c(1, 2, 3, 4) + c(0, 10)
```

Попробуем сложить векторы `c(1, 2, 3, 4)` и `c(0, 10, 100)`. Видим, что выводится предупреждение "Более длинная длина объекта не кратна более короткой длине объекта".

```{r}
c(1, 2, 3, 4) + c(0, 10, 100)
```

Во многих средах программирования стрелка вверх циклически переключает предыдущие команды. Попробуем нажимать стрелку вверх на клавиатуре, пока не дойдем до команды `(z \* 2 + 100)`, затем измените 100 на 1000 и нажмите Enter. Если стрелка вверх у вас не работает, просто введите исправленную команду.

```{r}
z * 2 + 1000
```

### Урок 2: Рабочее пространство и файлы

Определим, какой каталог использует сеанс R в качестве текущего рабочего каталога, используя `getcwd()`.

```{r}
getwd()
```

Перечислим все объекты в локальной рабочей области, используя `ls()`

```{r}
ls()
```

Присвоим 9 переменной `x`, используя `x <- 9`.

```{r}
x <- 9
```

Перечислите все файлы в вашем рабочем каталоге, используя `list.files()`.

```{r}
list.files()
```

Также можно использоваться `dir()`.

```{r}
dir()
```

Использованую функцию `args()` можно увидеть, какие аргументы может принимать функция.

```{r}
args(list.files)
```

Зададим в переменную `old.dir` нашу рабочую директорию. Это нужно, чтобы в конце к ней вернуться.

```{r}
old.dir <- getwd()
old.dir
```

Посмотрим документацию команды `dir.create` с помощью вопросительного знака.

```{r}
?dir.create
```

С помощью команды `dir.create()` создадим новый директорий с именем `testdir` в уже существующий. Чтобы работать в этой директории, надо задать её как рабочую с помощью команды `setwd()`.

Создадим файл `mytest.R`, используя функцию `file.create()` и проверим, какие файлы у нас лежат в новой директории. Чтобы проверить, существует ли `mytest.R` в рабочей директории, используем команду `file.exists()`. Посмотрим информацию о файле `mytest.R`, используя команду `file.info()`.

Переименуем файл `mytest.R` в `mytest2.R`, используя команду `file.rename()`. Сделаем копию файла `mytest2.R` и назовём копию `mytest3.R`, используя команду `file.copy()`. Укажем родительский путь к файлу `mytest3.R`, используя команду `file.path()`.

Можно использовать `file.path()` для построения путей к файлам и каталогам, которые не зависят от операционной системы, в которой выполняется наш R-код. Передадим `folder1` и `folder2` в качестве аргументов для создания независимого от платформы имени пути.

Создадим новый директорий в нашей рабочей директории и назовём его `testdir2`, а также создадим сабдиректорий и назовём его `testdir3`, используя только команды `dir.create()` и `file.path()`. Вернёмся обратно в рабочую директорию на компьютере, с помощью команды `setwd()`. Вспомним, что ранее мы заносили её в переменную `old.dir`.

```{r}
dir.create("testdir")
setwd("testdir")
getwd()

file.create("mytest.R")
dir()
file.exists("mytest.R")
file.info("mytest.R")

file.rename("mytest.R", "mytest2.R")
file.copy("mytest2.R", "mytest3.R")
file.path("mytest3.R")

file.path("folder1", "folder2")

dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE)
setwd(old.dir)
```

### Урок 3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать оператор `:`. Введём `1:20`, чтобы увидеть как это работает.

```{r}
1:20
```

Также мы можем создать последовательность из вещественных чисел. Для этого используем команду `pi:10`, чтобы создать последовательность от числа Пи.

```{r}
pi:10
```

Попробуем ввести `15:1`. Видим, что получится обратный список последовательности чисел.

```{r}
15:1
```

В случае оператора, подобного двоеточию, чтобы узнать информацию, необходимо поставить вопросительный знак до символа и сам символ в обратные кавычки.

```{r}
?`:`
```

Существует операция `seq()`, аналогичная оператору `:`. Убедимся в этом с помощью команды `seq(1, 20)`.

```{r}
seq(1, 20)
```

Можно задать последовательность чисел и указать шаг, на который будет сдвигаться генерация чисел. Создадим последовательность от 0 до 10 с шагом 0.5 с помощью команды `seq(0, 20, by=0.5)`.

```{r}
seq(0, 10, by=0.5)
```

Если нас не волнует, какое приращение задано и мы просто хотим создать последовательность из 30 чисел от 5 до 10. Создадим данную последовательность через команду `seq(5, 10, length=30)` и занесём её в переменную `my_seq`.

```{r}
my_seq <- seq(5, 10, length=30)
my_seq
```

Чтобы убедиться, что последовательность имеет длину 30, ипользуем команду `length()`.

```{r}
length(my_seq)
```

Теперь посмотрим как мы можем комбинировать команды между собой. Используем значение длины 30 и попробуем задать последовательность `1:30` с использованием команды `length(my_seq)`.

```{r}
1:length(my_seq)
```

Другой вариант - использовать seq(along.with = my_seq).

```{r}
seq(along.with = my_seq)
```

Однако, как и в случае со многими распространенными задачами, R имеет отдельную встроенную функцию для этой цели, называемую `seq_along()`. Она составляет на основе длины последловательности свою собственную.

```{r}
seq_along(my_seq)
```

Также существует функция повторения числа или вектора n-ное количество раз. Создадим вектор, который содержит в себе 40 нулей с помощью команды `rep(0, times = 40)`.

```{r}
rep(0, times = 40)
```

Если вместо этого мы хотим, чтобы наш вектор содержал 10 повторений вектора (0, 1, 2), мы можем выполнить `rep(c(0, 1, 2), times = 10)`.

```{r}
rep(c(0, 1, 2), times = 10)
```

Стоит отметить, что если нам требуется повторить каждый элемент, то на помощь придёт функция `each()`. Попробуем повторить 10 раз каждый из элементов вектора `c(0, 1, 2)` с помощью команды `rep(c(0, 1, 2), each = 10)`.

```{r}
rep(c(0, 1, 2), each = 10)
```

### Урок 4: Векторы

Сначала создайте числовой вектор `num_vect`, содержащий значения 0.5, 55, -10 и 6.

```{r}
num_vect <- c(0.5, 55, -10, 6)
```

Далее создадим переменную с именем ``tf`, которая получает результат `num_vect < 1`. В итоге мы получим вектор, содержащий 4 логических значения [TRUE | FALSE]. Выведем на экран значение переменной `tf`.

```{r}
tf <- num_vect < 1
tf
```

Далее выведем на экран результат работы команды `num_vect >= 6` без занесения в переменную.

```{r}
num_vect >= 6
```

Создаем символьный вектор, содержащий следующие слова: "My", "name", "is". И сохраним вектор в переменной с именем `my_char`.

```{r}
my_char <- c("My", "name", "is")
my_char
```

Введите `paste(my_char, collapse = " ")`. Убедимся, что в аргументе `collapse` между двойными кавычками есть пробел. 

```{r}
paste(my_char, collapse = " ")
```

Чтобы добавить имя в конец `my_char`, используем функцию c() следующим образом: `c(my_char, "your_name_here")`. Заключим  имя в двойные кавычки там, где я "your_name_here".

```{r}
my_name <- c(my_char, "Doluma")
my_name
```

Воспользуемся еще раз функцию `paste()`, чтобы объединить слова в my_name в одну символьную строку.

```{r}
paste(my_name, collapse = " ")
```

Мы можем соединить два символьных вектора, каждый из которых имеет длину 1 (т.е. соединить два слова). Попробуем вставить ("Hello","world!", sep = " "), где аргумент `sep` сообщает R, что хотим разделить соединенные элементы одним пробелом.

```{r}
paste("Hello", "world!", sep = " ")
```

Для немного более сложного примера можем объединить два вектора, каждый длиной 3. Используем функцию `paste()`, чтобы соединить целочисленный вектор 1:3 с символьным вектором `c("X", "Y", "Z")`. На этот раз используем `sep = ""`, чтобы не оставлять пробелов между соединяемыми элементами.

```{r}
paste(1:3, c("X", "Y", "Z"), sep = "")
```

## Оценка результата

Было пройдена 4 урока по языку программирования R.

## Вывод

В ходе практической работы были получены базовые навыки работы с RStudio Desktop и языком программирования R.