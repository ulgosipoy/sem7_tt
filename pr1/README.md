# Практическое работа 1
БИСО-01-20 Калбак

# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования
    R;
2.  Оформить отчет по изученному материалу.

## Исходные данные

1.  ОС Windows 10
2.  Интерпретатор языка R 4.3.0
3.  RStudio Desktop
4.  Библиотека `Swirl`

## План

1.  Установить библиотеку `swirl`
2.  Запустить в консоли `swirl::swirl()`
3.  Пройти 4 урока

## Ход выполнения работы

Для начала, установим библиотеку `swirl`.

    install.packages("swirl")

После этого запустим библиотеку с помощью команды `swirl::swirl()`.

    swirl::swirl()

### Урок 1: Основные блоки программирования на языке R

Интерактивный калькулятор - самая простая форма, которая может
использоваться в R. Введите `5 + 7` и нажмите Enter.

``` r
5 + 7
```

    [1] 12

Чтобы присвоить результат `5 + 7` новой переменной с именем `x`, вводите
`x <- 5 + 7`. Это можно прочитать как `x gets 5 plus 7`. Чтобы
просмотреть содержимое переменной `x`, просто введите `x` и нажмите
Enter.

``` r
x <- 5 + 7
x
```

    [1] 12

Теперь сохраните результат `x - 3` в новой переменной `y`.

``` r
y <- x - 3
y
```

    [1] 9

Самый простой способ создать вектор - с помощью функции c(), которая
расшифровывается как `concatenate` или `combine`. Чтобы создать вектор,
содержащий числа 1.1, 9 и 3.14, введите `c(1.1, 9, 3.14)`. Сохраним
результат в переменную`z`.

``` r
z <- c(1.1, 9, 3.14)
z
```

    [1] 1.10 9.00 3.14

Введите `?c` и нажмите Enter. Откроется файл справки для функции c().

``` r
?c
```

    starting httpd help server ... done

Вы можете объединить векторы, чтобы создать новый вектор. Создадим новый
вектор, содержащий `z, 555, z` в указанном порядке.

``` r
c(z, 555, z)
```

    [1]   1.10   9.00   3.14 555.00   1.10   9.00   3.14

Числовые векторы могут использоваться в арифметических выражениях.
Операции будут производиться с каждым элементом вектора.

``` r
z * 2 + 100
```

    [1] 102.20 118.00 106.28

Наиболее часто встречающиеся операции `+`, `-`, `/`, `*`, `^` могут
прописываться напрямую. Однако чтобы вычислить корень, нужно
использовать команду `sqrt()`, а чтобы взять по модулю - `abs()`.
Попробуем вычислить корень из z - 1 и занести в переменную `my_sqrt`.
Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление
по корню применялось к каждому из них.

``` r
my_sqrt <- sqrt(z - 1)
my_sqrt
```

    [1] 0.3162278 2.8284271 1.4628739

Создадим новую переменную `my_div` и занесём туда результат деления
значений `z` на `my_sqrt`. Затем узнаем что получилось в итоге и
убедимся, что операция выполняется по элементам (т.е. первому элементу
первого вектора соответствует первый элемент второго вектора).

``` r
my_div <- z / my_sqrt
my_div
```

    [1] 3.478505 3.181981 2.146460

Чтобы увидеть другой пример того, как работает эта векторная
“переработка”, попробуем добавить `c(1, 2, 3, 4)` и `c(0, 10)`. Видим,
что самый короткий вектор повторяется снова, пока более длинный не
закончится.

``` r
c(1, 2, 3, 4) + c(0, 10)
```

    [1]  1 12  3 14

Попробуем сложить векторы `c(1, 2, 3, 4)` и `c(0, 10, 100)`. Видим, что
выводится предупреждение “Более длинная длина объекта не кратна более
короткой длине объекта”.

``` r
c(1, 2, 3, 4) + c(0, 10, 100)
```

    Warning in c(1, 2, 3, 4) + c(0, 10, 100): longer object length is not a
    multiple of shorter object length

    [1]   1  12 103   4

Во многих средах программирования стрелка вверх циклически переключает
предыдущие команды. Попробуем нажимать стрелку вверх на клавиатуре, пока
не дойдем до команды `(z \* 2 + 100)`, затем измените 100 на 1000 и
нажмите Enter. Если стрелка вверх у вас не работает, просто введите
исправленную команду.

``` r
z * 2 + 1000
```

    [1] 1002.20 1018.00 1006.28

### Урок 2: Рабочее пространство и файлы

Определим, какой каталог использует сеанс R в качестве текущего рабочего
каталога, используя `getcwd()`.

``` r
getwd()
```

    [1] "C:/Users/Kalba/OneDrive/Рабочий стол/Долума/sem7_tt/Lab1/pr1"

Перечислим все объекты в локальной рабочей области, используя `ls()`

``` r
ls()
```

    [1] "has_annotations" "my_div"          "my_sqrt"         "x"              
    [5] "y"               "z"              

Присвоим 9 переменной `x`, используя `x <- 9`.

``` r
x <- 9
```

Перечислите все файлы в вашем рабочем каталоге, используя
`list.files()`.

``` r
list.files()
```

    [1] "lab1.qmd"       "lab1.rmarkdown" "Lab1.Rproj"     "README.md"     
    [5] "testdir"       

Также можно использоваться `dir()`.

``` r
dir()
```

    [1] "lab1.qmd"       "lab1.rmarkdown" "Lab1.Rproj"     "README.md"     
    [5] "testdir"       

Использованую функцию `args()` можно увидеть, какие аргументы может
принимать функция.

``` r
args(list.files)
```

    function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
        recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
        no.. = FALSE) 
    NULL

Зададим в переменную `old.dir` нашу рабочую директорию. Это нужно, чтобы
в конце к ней вернуться.

``` r
old.dir <- getwd()
old.dir
```

    [1] "C:/Users/Kalba/OneDrive/Рабочий стол/Долума/sem7_tt/Lab1/pr1"

Посмотрим документацию команды `dir.create` с помощью вопросительного
знака.

``` r
?dir.create
```

С помощью команды `dir.create()` создадим новый директорий с именем
`testdir` в уже существующий. Чтобы работать в этой директории, надо
задать её как рабочую с помощью команды `setwd()`.

Создадим файл `mytest.R`, используя функцию `file.create()` и проверим,
какие файлы у нас лежат в новой директории. Чтобы проверить, существует
ли `mytest.R` в рабочей директории, используем команду `file.exists()`.
Посмотрим информацию о файле `mytest.R`, используя команду
`file.info()`.

Переименуем файл `mytest.R` в `mytest2.R`, используя команду
`file.rename()`. Сделаем копию файла `mytest2.R` и назовём копию
`mytest3.R`, используя команду `file.copy()`. Укажем родительский путь к
файлу `mytest3.R`, используя команду `file.path()`.

Можно использовать `file.path()` для построения путей к файлам и
каталогам, которые не зависят от операционной системы, в которой
выполняется наш R-код. Передадим `folder1` и `folder2` в качестве
аргументов для создания независимого от платформы имени пути.

Создадим новый директорий в нашей рабочей директории и назовём его
`testdir2`, а также создадим сабдиректорий и назовём его `testdir3`,
используя только команды `dir.create()` и `file.path()`. Вернёмся
обратно в рабочую директорию на компьютере, с помощью команды `setwd()`.
Вспомним, что ранее мы заносили её в переменную `old.dir`.

``` r
dir.create("testdir")
```

    Warning in dir.create("testdir"): 'testdir' already exists

``` r
setwd("testdir")
getwd()
```

    [1] "C:/Users/Kalba/OneDrive/Рабочий стол/Долума/sem7_tt/Lab1/pr1/testdir"

``` r
file.create("mytest.R")
```

    [1] TRUE

``` r
dir()
```

    [1] "mytest.R"  "mytest2.R" "mytest3.R" "testdir2" 

``` r
file.exists("mytest.R")
```

    [1] TRUE

``` r
file.info("mytest.R")
```

             size isdir mode               mtime               ctime
    mytest.R    0 FALSE  666 2023-12-21 21:05:35 2023-12-21 21:05:35
                           atime exe
    mytest.R 2023-12-21 21:05:35  no

``` r
file.rename("mytest.R", "mytest2.R")
```

    [1] TRUE

``` r
file.copy("mytest2.R", "mytest3.R")
```

    [1] FALSE

``` r
file.path("mytest3.R")
```

    [1] "mytest3.R"

``` r
file.path("folder1", "folder2")
```

    [1] "folder1/folder2"

``` r
dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE)
```

    Warning in dir.create(file.path("testdir2", "testdir3"), recursive = TRUE):
    'testdir2\testdir3' already exists

``` r
setwd(old.dir)
```

### Урок 3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать
оператор `:`. Введём `1:20`, чтобы увидеть как это работает.

``` r
1:20
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Также мы можем создать последовательность из вещественных чисел. Для
этого используем команду `pi:10`, чтобы создать последовательность от
числа Пи.

``` r
pi:10
```

    [1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

Попробуем ввести `15:1`. Видим, что получится обратный список
последовательности чисел.

``` r
15:1
```

     [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

В случае оператора, подобного двоеточию, чтобы узнать информацию,
необходимо поставить вопросительный знак до символа и сам символ в
обратные кавычки.

``` r
?`:`
```

Существует операция `seq()`, аналогичная оператору `:`. Убедимся в этом
с помощью команды `seq(1, 20)`.

``` r
seq(1, 20)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Можно задать последовательность чисел и указать шаг, на который будет
сдвигаться генерация чисел. Создадим последовательность от 0 до 10 с
шагом 0.5 с помощью команды `seq(0, 20, by=0.5)`.

``` r
seq(0, 10, by=0.5)
```

     [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0
    [16]  7.5  8.0  8.5  9.0  9.5 10.0

Если нас не волнует, какое приращение задано и мы просто хотим создать
последовательность из 30 чисел от 5 до 10. Создадим данную
последовательность через команду `seq(5, 10, length=30)` и занесём её в
переменную `my_seq`.

``` r
my_seq <- seq(5, 10, length=30)
my_seq
```

     [1]  5.000000  5.172414  5.344828  5.517241  5.689655  5.862069  6.034483
     [8]  6.206897  6.379310  6.551724  6.724138  6.896552  7.068966  7.241379
    [15]  7.413793  7.586207  7.758621  7.931034  8.103448  8.275862  8.448276
    [22]  8.620690  8.793103  8.965517  9.137931  9.310345  9.482759  9.655172
    [29]  9.827586 10.000000

Чтобы убедиться, что последовательность имеет длину 30, ипользуем
команду `length()`.

``` r
length(my_seq)
```

    [1] 30

Теперь посмотрим как мы можем комбинировать команды между собой.
Используем значение длины 30 и попробуем задать последовательность
`1:30` с использованием команды `length(my_seq)`.

``` r
1:length(my_seq)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    [26] 26 27 28 29 30

Другой вариант - использовать seq(along.with = my_seq).

``` r
seq(along.with = my_seq)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    [26] 26 27 28 29 30

Однако, как и в случае со многими распространенными задачами, R имеет
отдельную встроенную функцию для этой цели, называемую `seq_along()`.
Она составляет на основе длины последловательности свою собственную.

``` r
seq_along(my_seq)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    [26] 26 27 28 29 30

Также существует функция повторения числа или вектора n-ное количество
раз. Создадим вектор, который содержит в себе 40 нулей с помощью команды
`rep(0, times = 40)`.

``` r
rep(0, times = 40)
```

     [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    [39] 0 0

Если вместо этого мы хотим, чтобы наш вектор содержал 10 повторений
вектора (0, 1, 2), мы можем выполнить `rep(c(0, 1, 2), times = 10)`.

``` r
rep(c(0, 1, 2), times = 10)
```

     [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

Стоит отметить, что если нам требуется повторить каждый элемент, то на
помощь придёт функция `each()`. Попробуем повторить 10 раз каждый из
элементов вектора `c(0, 1, 2)` с помощью команды
`rep(c(0, 1, 2), each = 10)`.

``` r
rep(c(0, 1, 2), each = 10)
```

     [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2
